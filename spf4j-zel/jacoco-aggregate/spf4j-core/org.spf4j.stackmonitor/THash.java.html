<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>THash.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-zel</a> &gt; <a href="../index.html" class="el_bundle">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.stackmonitor</a> &gt; <span class="el_source">THash.java</span></div><h1>THash.java</h1><pre class="source lang-java linenums">//CHECKSTYLE:OFF
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2001, Eric D. Friedman All Rights Reserved.
// Copyright (c) 2009, Rob Eden All Rights Reserved.
// Copyright (c) 2009, Jeff Randall All Rights Reserved.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
///////////////////////////////////////////////////////////////////////////////

package org.spf4j.stackmonitor;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import gnu.trove.impl.Constants;
import gnu.trove.impl.HashFunctions;
import gnu.trove.impl.PrimeFinder;

import java.io.Externalizable;
import java.io.ObjectOutput;
import java.io.IOException;
import java.io.ObjectInput;



/**
 * Base class for hashtables that use open addressing to resolve
 * collisions.
 * removed compaction element to reduce memory footprint.
 * use case for this implementation does not have removes.
 *
 * Created: Wed Nov 28 21:11:16 2001
 *
 * @author Eric D. Friedman
 * @author Rob Eden (auto-compaction)
 * @author Jeff Randall
 * @author zfarkas
 *
 * @version $Id: THash.java,v 1.1.2.4 2010/03/02 00:55:34 robeden Exp $
 */
@SuppressFBWarnings
abstract public class THash implements Externalizable {
    @SuppressWarnings( { &quot;UnusedDeclaration&quot; } )
    static final long serialVersionUID = -1792948471915530295L;

    /** the load above which rehashing occurs. */
<span class="fc" id="L57">    protected static final float DEFAULT_LOAD_FACTOR = Float.parseFloat(System.getProperty(&quot;spf4j.methodMap.loadFactor&quot;,</span>
            &quot;0.7&quot;));

    /**
     * the default initial capacity for the hash table.  This is one
     * less than a prime value because one is added to it when
     * searching for a prime capacity to account for the free slot
     * required by open addressing. Thus, the real default capacity is
     * 11.
     */
    protected static final int DEFAULT_CAPACITY = Constants.DEFAULT_CAPACITY;


    /** the current number of occupied slots in the hash. */
    protected transient int _size;

    /**
     * The maximum number of elements allowed without allocating more
     * space.
     */
    protected int _maxSize;


    /**
     * Creates a new &lt;code&gt;THash&lt;/code&gt; instance with the default
     * capacity and load factor.
     */
    public THash() {
<span class="nc" id="L85">        this( DEFAULT_CAPACITY );</span>
<span class="nc" id="L86">    }</span>




    /**
     * Creates a new &lt;code&gt;THash&lt;/code&gt; instance with a prime capacity
     * at or near the minimum needed to hold &lt;tt&gt;initialCapacity&lt;/tt&gt;
     * elements with load factor &lt;tt&gt;loadFactor&lt;/tt&gt; without triggering
     * a rehash.
     *
     * @param initialCapacity an &lt;code&gt;int&lt;/code&gt; value
     * @param loadFactor      a &lt;code&gt;float&lt;/code&gt; value
     */
    public THash( int initialCapacity) {
<span class="fc" id="L101">        super();</span>
<span class="fc" id="L102">        setUp( HashFunctions.fastCeil( initialCapacity / DEFAULT_LOAD_FACTOR ) );</span>
<span class="fc" id="L103">    }</span>


    /**
     * Tells whether this set is currently holding any elements.
     *
     * @return a &lt;code&gt;boolean&lt;/code&gt; value
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L112" title="All 2 branches covered.">        return 0 == _size;</span>
    }


    /**
     * Returns the number of distinct elements in this collection.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; value
     */
    public int size() {
<span class="fc" id="L122">        return _size;</span>
    }


    /** @return the current physical capacity of the hash table. */
    abstract public int capacity();


    /**
     * Ensure that this hashtable has sufficient capacity to hold
     * &lt;tt&gt;desiredCapacity&lt;tt&gt; &lt;b&gt;additional&lt;/b&gt; elements without
     * requiring a rehash.  This is a tuning method you can call
     * before doing a large insert.
     *
     * @param desiredCapacity an &lt;code&gt;int&lt;/code&gt; value
     */

    public void ensureCapacity(int desiredCapacity) {
<span class="fc" id="L140">        int requiredSize = desiredCapacity + _size;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (requiredSize &gt; _maxSize) {</span>
<span class="fc" id="L142">            rehash(PrimeFinder.nextPrime(Math.max( _size + (_size &gt;&gt; 1) + 1,</span>
<span class="fc" id="L143">				HashFunctions.fastCeil((requiredSize) / DEFAULT_LOAD_FACTOR ) + 1) ) );</span>
<span class="fc" id="L144">            computeMaxSize(capacity());</span>
        }
<span class="fc" id="L146">    }</span>


    /**
     * Delete the record at &lt;tt&gt;index&lt;/tt&gt;.  Reduces the size of the
     * collection by one.
     *
     * @param index an &lt;code&gt;int&lt;/code&gt; value
     */
    protected void removeAt( int index ) {
<span class="nc" id="L156">        _size--;</span>
<span class="nc" id="L157">    }</span>


    /** Empties the collection. */
    public void clear() {
<span class="nc" id="L162">        _size = 0;</span>
<span class="nc" id="L163">    }</span>


    /**
     * initializes the hashtable to a prime capacity which is at least
     * &lt;tt&gt;initialCapacity + 1&lt;/tt&gt;.
     *
     * @param initialCapacity an &lt;code&gt;int&lt;/code&gt; value
     * @return the actual capacity chosen
     */
    protected int setUp( int initialCapacity ) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (initialCapacity == 0) {</span>
<span class="fc" id="L175">          return 0;</span>
        }
        int capacity;

<span class="fc" id="L179">        capacity = PrimeFinder.nextPrime( initialCapacity );</span>
<span class="fc" id="L180">        computeMaxSize( capacity );</span>

<span class="fc" id="L182">        return capacity;</span>
    }


    /**
     * Rehashes the set.
     *
     * @param newCapacity an &lt;code&gt;int&lt;/code&gt; value
     */
    protected abstract void rehash( int newCapacity );



    /**
     * Computes the values of maxSize. There will always be at least
     * one free slot required.
     *
     * @param capacity an &lt;code&gt;int&lt;/code&gt; value
     */
    protected void computeMaxSize( int capacity ) {
        // need at least one free slot for open addressing
<span class="fc" id="L203">        _maxSize = Math.min( capacity - 1, (int) ( capacity * DEFAULT_LOAD_FACTOR ) );</span>
<span class="fc" id="L204">    }</span>


    /**
     * After an insert, this hook is called to adjust the size/free
     * values of the set and to perform rehashing if necessary.
     *
     * @param usedFreeSlot the slot
     */
    protected final void postInsertHook() {
<span class="fc" id="L214">        ++_size;</span>
<span class="fc" id="L215">    }</span>


    protected int calculateGrownCapacity() {
<span class="nc" id="L219">        return capacity() &lt;&lt; 1;</span>
    }


    public void writeExternal( ObjectOutput out ) throws IOException {
        // VERSION
<span class="fc" id="L225">        out.writeByte( 0 );</span>
<span class="fc" id="L226">    }</span>


    public void readExternal( ObjectInput in )
            throws IOException, ClassNotFoundException {

        // VERSION
<span class="fc" id="L233">        in.readByte();</span>


<span class="fc" id="L236">        setUp( (int) Math.ceil( DEFAULT_CAPACITY / DEFAULT_LOAD_FACTOR ) );</span>
<span class="fc" id="L237">    }</span>
}// THash
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>