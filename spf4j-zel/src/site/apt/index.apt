The Z Expression Language

 Scope: A simple but easy to extend language for doing expression evalutions and calculations in java.
 

 Now there are a few other components out there that do a similar job, here is what it's different (or not :-) ) about this particular implementation:

  1. Implemented using javaCC

  2. Asynchronous programming (function calls can be executed asynchronously or asynchronously)

  3. Expressions are compiled providing decent execution performance. 
     (Outperforms SPEL(Spring) by a few orders of magnitude)

  4. Integer mathematical operations do not overflow.
     Real number representation can be used seamlessly with decimal or binary representation.

  5. Everything is an object, numbers, strings, functions.....

  6. There is only one type of variable:  reference to object,
     you declare a variable by assigning an object to it, all variables are local to the current exec context.
   
  7. ZEL uses the last value out principle, expressions will return the last evaluated expression.
     There is a return keyword that can be used, but it is optional.

  8. Support for deterministic functions, (aka memorization) executions will be cached for deterministic functions

  10. LGPL license

 Here is how you would use the evaluator in your java code:

+-----------------------------------------------------------------------
EX1:    // mathematical expressions 

        Program prog = Program.compile("1+5*4/(1+1)");
        Number result = (Number) prog.execute();

EX2:    // formulas with decimal numbers can be written easer than directly in java

        BigDecimal result = (BigDecimal) Program.compile("use dec 128; (1.0/3) * 3 + (1 - 1.0/3*3)").execute();

EX3:    // java integration, java objects are suppoted just like in java:

        Program prog = Program.compile("a.toString().substring(0, 1 + 1)", "a");
        String result = (String) prog.execute(100);

EX4:    // fibonacci recursive definition executes in O(n)

        String program =
                  "fib = func det (x) { fib(x-1) + fib(x-2) };\n"
                + "fib(0) = 0;"
                + "fib(1) = 1;"
                + "fib(200)"

        Program compiledProgram = Program.compile(program);
        Number result = (Number) compiledProgram.execute();

EX5:    // Async programming

        replica = func async (x) {
            sleep random() * 1000;
            out(x, " finished\n");
            return x
        };
        out(first(replica(1), replica(2), replica(3)), " finished first\n");

EX5:    // Async programming, parallel PI

        piPart = func (s, x) {
            term = func sync (k) {4 * (-1 ** k) / (2d * k + 1)};
            for i = s; i < x; i++ {
              parts[i] = term(i) 
            };

            for result = 0, i = s; i < x; i++ {
              result = result + parts[i] 
            };
            return result
        };

        pi = func (x, breakup) {
            range = x / breakup;
            l = breakup - 1;
            for i = 0, result = 0, k = 0; i < l; i++ {
              part[i] = piPart(k, k + range);
              k = k + range
            };
            part[i] = piPart(k, x);
            for i = 0, result = 0; i < breakup; i = i + 1 {
               result = result + part[i] 
            };
            return result
        };
        pi(x, 5)


 
+-----------------------------------------------------------------------
  
