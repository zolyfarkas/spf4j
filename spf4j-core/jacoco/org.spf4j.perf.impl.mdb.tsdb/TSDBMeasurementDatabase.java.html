<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TSDBMeasurementDatabase.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spf4j-core</a> &gt; <a href="index.html" class="el_package">org.spf4j.perf.impl.mdb.tsdb</a> &gt; <span class="el_source">TSDBMeasurementDatabase.java</span></div><h1>TSDBMeasurementDatabase.java</h1><pre class="source lang-java linenums"> /*
 * Copyright (c) 2001, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.spf4j.perf.impl.mdb.tsdb;

import com.google.common.base.Charsets;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import org.spf4j.base.AbstractRunnable;
import org.spf4j.base.Arrays;
import org.spf4j.base.DefaultScheduler;
import org.spf4j.base.Pair;
import org.spf4j.perf.EntityMeasurementsInfo;
import org.spf4j.perf.MeasurementDatabase;
import org.spf4j.perf.impl.chart.Charts;
import org.spf4j.perf.tsdb.ColumnInfo;
import org.spf4j.perf.tsdb.TimeSeriesDatabase;
import java.awt.image.BufferedImage;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.PreDestroy;
import javax.annotation.concurrent.ThreadSafe;
import javax.imageio.ImageIO;
import javax.management.InstanceAlreadyExistsException;
import javax.management.MBeanRegistrationException;
import javax.management.MalformedObjectNameException;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectName;
import org.jfree.chart.JFreeChart;
import org.joda.time.DateTimeConstants;
import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author zoly
 */
@ThreadSafe
public final class TSDBMeasurementDatabase
    implements MeasurementDatabase, Closeable, TSDBMeasurementDatabaseMBean {

    private final TimeSeriesDatabase database;
    private volatile ScheduledFuture&lt;?&gt; future;
<span class="fc" id="L69">    private static final Logger LOG = LoggerFactory.getLogger(TSDBMeasurementDatabase.class);</span>

<span class="fc" id="L71">    public TSDBMeasurementDatabase(final String databaseName) throws IOException {</span>
<span class="fc" id="L72">        this.database = new TimeSeriesDatabase(databaseName, new byte[]{});</span>
<span class="fc" id="L73">    }</span>
<span class="fc" id="L74">    private static final AtomicInteger COUNTER = new AtomicInteger(0);</span>

    public void registerJmx() throws MalformedObjectNameException, InstanceAlreadyExistsException,
            MBeanRegistrationException, NotCompliantMBeanException {
<span class="fc" id="L78">        ManagementFactory.getPlatformMBeanServer().registerMBean(this,</span>
                new ObjectName(&quot;SPF4J:name=TSDBMeasurementDatabase&quot; + COUNTER.getAndIncrement()));
<span class="fc" id="L80">    }</span>

    public void closeOnShutdown() {
<span class="fc" id="L83">        Runtime.getRuntime().addShutdownHook(new Thread(new AbstractRunnable(false) {</span>
            @Override
            public void doRun() throws Exception {
<span class="fc" id="L86">                close();</span>
<span class="fc" id="L87">            }</span>
        }, &quot;tsdb shutdown&quot;));
<span class="fc" id="L89">    }</span>

    public void flushEvery(final int intervalMillis) {
<span class="fc" id="L92">        future = DefaultScheduler.INSTANCE.scheduleAtFixedRate(new AbstractRunnable(false) {</span>
            @Override
            public void doRun() throws Exception {
<span class="nc" id="L95">                database.flush();</span>
<span class="nc" id="L96">            }</span>
        }, intervalMillis, intervalMillis, TimeUnit.MILLISECONDS);
<span class="fc" id="L98">    }</span>

    @Override
    public void alocateMeasurements(final EntityMeasurementsInfo measurement,
                                    final int sampleTimeMillis) throws IOException {
<span class="fc" id="L103">        String groupName = measurement.getMeasuredEntity().toString();</span>
<span class="fc" id="L104">        alocateMeasurements(groupName, measurement, sampleTimeMillis);</span>
<span class="fc" id="L105">    }</span>
    
    private void alocateMeasurements(final String groupName, final EntityMeasurementsInfo measurement,
            final int sampleTimeMillis) throws IOException {
<span class="fc" id="L109">        synchronized (database) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (!database.hasColumnGroup(groupName)) {</span>
<span class="fc" id="L111">                String[] measurementNames = measurement.getMeasurementNames();</span>
<span class="fc" id="L112">                byte[] uom = measurement.getUnitOfMeasurement().getBytes(Charsets.UTF_8);</span>
<span class="fc" id="L113">                byte[][] metaData = new byte[measurementNames.length][];</span>
<span class="fc" id="L114">                String [] uoms = measurement.getMeasurementUnits();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                for (int i = 0; i &lt; metaData.length; i++) {</span>
<span class="fc" id="L116">                    metaData[i] = uoms[i].getBytes(Charsets.UTF_8);</span>
                }
<span class="fc" id="L118">                database.addColumnGroup(groupName, uom, sampleTimeMillis, measurementNames,</span>
                        metaData);
            }
<span class="pc" id="L121">        }</span>
<span class="fc" id="L122">    }</span>


    @Override
    public void saveMeasurements(final EntityMeasurementsInfo measurementInfo,
                    final long[] measurements, final long timeStampMillis, final int sampleTimeMillis)
            throws IOException {
<span class="fc" id="L129">        String groupName = measurementInfo.getMeasuredEntity().toString();</span>
<span class="fc" id="L130">        alocateMeasurements(groupName, measurementInfo, sampleTimeMillis);</span>
<span class="fc" id="L131">        database.write(timeStampMillis, groupName, measurements);</span>
<span class="fc" id="L132">    }</span>

    @PreDestroy
    @Override
    public void close() throws IOException {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (future != null) {</span>
<span class="fc" id="L138">            future.cancel(false);</span>
        }
<span class="fc" id="L140">        database.close();</span>
<span class="fc" id="L141">    }</span>

    private static String fixName(final String name) {
<span class="fc" id="L144">        StringBuilder result = new StringBuilder(name.length());</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (int i = 0; i &lt; name.length(); i++) {</span>
<span class="fc" id="L146">            char c = name.charAt(i);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (Character.isJavaIdentifierPart(c)) {</span>
<span class="fc" id="L148">                result.append(c);</span>
            }
        }
<span class="fc" id="L151">        return result.toString();</span>
    }

    @Override
    public List&lt;String&gt; generateCharts(final int width, final int height) throws IOException {
<span class="nc" id="L156">        long startTime = ManagementFactory.getRuntimeMXBean().getStartTime();</span>
<span class="nc" id="L157">        long endTime = System.currentTimeMillis();</span>
<span class="nc" id="L158">        return generateCharts(startTime, endTime, width, height);</span>
    }

    /**
     * Quantized recorders will have min, max avg charts and distribution charts
     * generated. Counting recorders will have simple charts generated.
     *
     * @param startTimeMillis
     * @param endTimeMillis
     * @param width
     * @param height
     * @return
     * @throws IOException
     */
    @Override
    public List&lt;String&gt; generateCharts(final long startTimeMillis, final long endTimeMillis,
            final int width, final int height) throws IOException {
        try {
<span class="fc" id="L176">            database.flush();</span>
<span class="fc" id="L177">            List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L178">            Collection&lt;ColumnInfo&gt; columnsInfo = database.getColumnsInfo();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            for (ColumnInfo info : columnsInfo) {</span>
<span class="fc" id="L180">                Pair&lt;long[], long[][]&gt; data = database.read(info.getGroupName(), startTimeMillis, endTimeMillis);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                if (data.getFirst().length &gt; 0) {</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                    if (canGenerateMinMaxAvgCount(info)) {</span>
<span class="fc" id="L183">                        result.add(generateMinMaxAvgCountChart(info, data, width, height));</span>
                    }
<span class="fc bfc" id="L185" title="All 2 branches covered.">                    if (canGenerateHeatChart(info)) {</span>
<span class="fc" id="L186">                        result.add(generateHeatChart(info, data, width, height));</span>
                    }
                }
<span class="fc" id="L189">            }</span>
<span class="fc" id="L190">            Multimap&lt;String, ColumnInfo&gt; counters = getCounters(columnsInfo);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            for (Map.Entry&lt;String, Collection&lt;ColumnInfo&gt;&gt; entry : counters.asMap().entrySet()) {</span>
<span class="fc" id="L192">                long[][] timestamps = new long[entry.getValue().size()][];</span>
<span class="fc" id="L193">                double[][] cdata = new double[entry.getValue().size()][];</span>
<span class="fc" id="L194">                double[][] cdata2 = new double[entry.getValue().size()][];</span>
<span class="fc" id="L195">                int i = 0;</span>
<span class="fc" id="L196">                String[] measurementNames = new String[cdata.length];</span>
<span class="fc" id="L197">                String[] measurementNames2 = new String[cdata2.length];</span>
<span class="fc" id="L198">                String uom1 = &quot;count&quot;;</span>
<span class="fc" id="L199">                String uom2 = &quot;&quot;;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                for (ColumnInfo colInfo : entry.getValue()) {</span>
<span class="fc" id="L201">                    Pair&lt;long[], long[][]&gt; data = database.read(colInfo.getGroupName(), startTimeMillis, endTimeMillis);</span>
<span class="fc" id="L202">                    timestamps[i] = data.getFirst();</span>
<span class="fc" id="L203">                    cdata[i] = Arrays.getColumnAsDoubles(data.getSecond(), colInfo.getColumnIndex(&quot;count&quot;));</span>
<span class="fc" id="L204">                    cdata2[i] = Arrays.getColumnAsDoubles(data.getSecond(), colInfo.getColumnIndex(&quot;total&quot;));</span>
<span class="fc" id="L205">                    measurementNames[i] = colInfo.getGroupName() + &quot;.count&quot;;</span>
<span class="fc" id="L206">                    measurementNames2[i] = colInfo.getGroupName() + &quot;.total&quot;;</span>
<span class="fc" id="L207">                    uom2 = new String(colInfo.getGroupMetaData(), Charsets.UTF_8);</span>
<span class="fc" id="L208">                    i++;</span>
<span class="fc" id="L209">                }</span>
<span class="fc" id="L210">                result.add(generateCountChart(entry.getKey(), timestamps, measurementNames,</span>
                        measurementNames2, uom1, uom2, cdata, cdata2, width, height));
<span class="fc" id="L212">            }</span>
<span class="fc" id="L213">            LOG.info(&quot;Generated charts {}&quot;, result);</span>
<span class="fc" id="L214">            return result;</span>
<span class="nc" id="L215">        } catch (IOException ex) {</span>
<span class="nc" id="L216">            LOG.error(&quot;Error while generating charts&quot;, ex);</span>
<span class="nc" id="L217">            throw ex;</span>
<span class="nc" id="L218">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L219">            LOG.error(&quot;Error while generating charts&quot;, ex);</span>
<span class="nc" id="L220">            throw ex;</span>
        }
    }

    private static Multimap&lt;String, ColumnInfo&gt; getCounters(final Collection&lt;ColumnInfo&gt; columnInfos) {
<span class="fc" id="L225">        Multimap&lt;String, ColumnInfo&gt; result = HashMultimap.create();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (ColumnInfo info : columnInfos) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (isCounterOnly(info)) {</span>
<span class="fc" id="L228">                String groupName = info.getGroupName();</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                if (groupName.startsWith(&quot;(&quot;)) {</span>
<span class="fc" id="L230">                    int cidx = groupName.indexOf(',');</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                    if (cidx &gt; 0) {</span>
<span class="fc" id="L232">                        groupName = groupName.substring(1, cidx);</span>
                    }
                }
<span class="fc" id="L235">                result.put(groupName, info);</span>
<span class="fc" id="L236">            }</span>
        }
<span class="fc" id="L238">        return result;</span>
    }

    public static boolean isCounterOnly(final ColumnInfo info) {
<span class="fc" id="L242">        String[] columns = info.getColumnNames();</span>
<span class="pc bpc" id="L243" title="2 of 6 branches missed.">        return columns.length == 2 &amp;&amp; columns[0].equals(&quot;count&quot;)</span>
                &amp;&amp; columns[1].equals(&quot;total&quot;);
    }

    public static boolean canGenerateMinMaxAvgCount(final ColumnInfo info) {
<span class="pc bpc" id="L248" title="3 of 8 branches missed.">        return ((info.getColumnIndex(&quot;min&quot;) &gt;= 0)</span>
                &amp;&amp; (info.getColumnIndex(&quot;max&quot;) &gt;= 0)
                &amp;&amp; (info.getColumnIndex(&quot;total&quot;) &gt;= 0)
                &amp;&amp; (info.getColumnIndex(&quot;count&quot;) &gt;= 0));
    }

    public static boolean canGenerateCount(final ColumnInfo info) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        return ((info.getColumnIndex(&quot;count&quot;) &gt;= 0));</span>
    }
    
    
    public static boolean canGenerateHeatChart(final ColumnInfo info) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        for (String mname : info.getColumnNames()) {</span>
<span class="pc bpc" id="L261" title="1 of 4 branches missed.">            if (mname.startsWith(&quot;Q&quot;) &amp;&amp; mname.contains(&quot;_&quot;)) {</span>
<span class="fc" id="L262">                return true;</span>
            }
        }
<span class="fc" id="L265">        return false;</span>
    }

    private String generateMinMaxAvgCountChart(
            final ColumnInfo info, final Pair&lt;long[], long[][]&gt; data,
            final int width, final int height) throws IOException {
<span class="fc" id="L271">        long[][] vals = data.getSecond();</span>
<span class="fc" id="L272">        double[] min = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;min&quot;));</span>
<span class="fc" id="L273">        double[] max = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;max&quot;));</span>
<span class="fc" id="L274">        double[] total = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;total&quot;));</span>
<span class="fc" id="L275">        double[] count = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;count&quot;));</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (int i = 0; i &lt; count.length; i++) {</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            if (count[i] == 0) {</span>
<span class="nc" id="L278">                min[i] = 0;</span>
<span class="nc" id="L279">                max[i] = 0;</span>
            }
        }
<span class="fc" id="L282">        long[] timestamps = data.getFirst();</span>
<span class="fc" id="L283">        BufferedImage combined = Charts.createMinMaxAvgCountImg(&quot;Measurements for &quot;</span>
                + info.getGroupName() + &quot; generated by spf4j&quot;,
                timestamps, min, max, total, count, new String(info.getGroupMetaData(), Charsets.UTF_8), width, height);
<span class="fc" id="L286">        File dbFile = new File(database.getDBFilePath());</span>
<span class="fc" id="L287">        File graphicFile = File.createTempFile(dbFile.getName() + &quot;_&quot; + fixName(info.getGroupName()), &quot;.mmac.png&quot;,</span>
                dbFile.getParentFile());
<span class="fc" id="L289">        ImageIO.write(combined, &quot;png&quot;, graphicFile);</span>
<span class="fc" id="L290">        return graphicFile.getPath();</span>
    }

    private String generateCountChart(
            final String groupName, final long[][] timestamps,
            final String[] measurementNames, final String[] measurementNames2,
            final String uom1, final String uom2,
            final double[][] measurements, final double[][] measurements2,
            final int width, final int height) throws IOException {
<span class="fc" id="L299">        BufferedImage count = Charts.createTimeSeriesJFreeChart(&quot;Measurements for &quot;</span>
                + groupName + &quot; generated by spf4j&quot;,
                timestamps, measurementNames, uom1, measurements).createBufferedImage(width, height / 2);

<span class="fc" id="L303">        BufferedImage total = Charts.createTimeSeriesJFreeChart(null,</span>
                timestamps, measurementNames2, uom2, measurements2).createBufferedImage(width, height / 2);

<span class="fc" id="L306">        BufferedImage combined = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span>
<span class="fc" id="L307">        combined.getGraphics().drawImage(count, 0, 0, null);</span>
<span class="fc" id="L308">        combined.getGraphics().drawImage(total, 0, height / 2, null);</span>


<span class="fc" id="L311">        File dbFile = new File(database.getDBFilePath());</span>
<span class="fc" id="L312">        File graphicFile = File.createTempFile(dbFile.getName() + &quot;_&quot; + fixName(groupName), &quot;.count.png&quot;,</span>
                dbFile.getParentFile());
<span class="fc" id="L314">        ImageIO.write(combined, &quot;png&quot;, graphicFile);</span>
<span class="fc" id="L315">        return graphicFile.getPath();</span>
    }


    private String generateHeatChart(final ColumnInfo info, final Pair&lt;long[], long[][]&gt; data,
            final int width, final int height) throws IOException {
<span class="fc" id="L321">        JFreeChart chart = TimeSeriesDatabase.createHeatJFreeChart(data, info);</span>
<span class="fc" id="L322">        BufferedImage img = chart.createBufferedImage(width, height);</span>
<span class="fc" id="L323">        File dbFile = new File(database.getDBFilePath());</span>
<span class="fc" id="L324">        File graphicFile = File.createTempFile(dbFile.getName() + &quot;_&quot; + fixName(info.getGroupName()), &quot;.dist.png&quot;,</span>
                dbFile.getParentFile());
<span class="fc" id="L326">        ImageIO.write(img, &quot;png&quot;, graphicFile);</span>
<span class="fc" id="L327">        return graphicFile.getAbsolutePath();</span>
    }

    @Override
    public List&lt;String&gt; generate(final Properties props) throws IOException {
<span class="nc" id="L332">        int width = Integer.valueOf(props.getProperty(&quot;width&quot;, &quot;1200&quot;));</span>
<span class="nc" id="L333">        int height = Integer.valueOf(props.getProperty(&quot;height&quot;, &quot;800&quot;));</span>
<span class="nc" id="L334">        long startTime = Long.valueOf(props.getProperty(&quot;startTime&quot;,</span>
                Long.toString(new LocalDate().withDayOfWeek(DateTimeConstants.MONDAY).toDate().getTime())));
<span class="nc" id="L336">        long endTime = Long.valueOf(props.getProperty(&quot;endTime&quot;, Long.toString(System.currentTimeMillis())));</span>
<span class="nc" id="L337">        return generateCharts(startTime, endTime, width, height);</span>
    }

    @Override
    public List&lt;String&gt; getParameters() {
<span class="nc" id="L342">        return java.util.Arrays.asList(&quot;width&quot;, &quot;height&quot;, &quot;startTime&quot;, &quot;endTime&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>