<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FailSafeExecutorImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.failsafe.concurrent</a> &gt; <span class="el_source">FailSafeExecutorImpl.java</span></div><h1>FailSafeExecutorImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.failsafe.concurrent;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spf4j.base.AbstractRunnable;
import org.spf4j.failsafe.RetryPredicate;
import org.spf4j.base.UncheckedExecutionException;
import org.spf4j.concurrent.DefaultExecutor;
import org.spf4j.concurrent.InterruptibleCompletableFuture;

/**
 * Executor that will call Callables with retry. This executor cannot be used inside a Completion service.
 *
 *
 * @author zoly
 */
public final class FailSafeExecutorImpl implements FailSafeExecutor {

<span class="fc" id="L63">  private static final Logger LOG = LoggerFactory.getLogger(FailSafeExecutorImpl.class);</span>

<span class="fc" id="L65">  private static final Future&lt;?&gt; SHUTDOWN = new Future() {</span>
    @Override
    public boolean cancel(final boolean mayInterruptIfRunning) {
<span class="nc" id="L68">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isCancelled() {
<span class="nc" id="L73">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isDone() {
<span class="nc" id="L78">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object get()  {
<span class="nc" id="L83">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object get(final long timeout, final TimeUnit unit) {
<span class="nc" id="L88">      throw new UnsupportedOperationException();</span>
    }
  };

  private final ExecutorService executionService;
<span class="fc" id="L93">  private final DelayQueue&lt;DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;&gt; executionEvents = new DelayQueue&lt;&gt;();</span>
  private volatile Future&lt;?&gt; retryManagerFuture;
<span class="fc" id="L95">  private final Object sync = new Object();</span>

  private void startRetryManager() {
<span class="fc" id="L98">    Future&lt;?&gt; rm = retryManagerFuture;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (rm == null) {</span>
<span class="fc" id="L100">      synchronized (sync) {</span>
<span class="fc" id="L101">        rm = retryManagerFuture;</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (rm == null) {</span>
<span class="fc" id="L103">          rm = DefaultExecutor.INSTANCE.submit(new RetryManager());</span>
<span class="fc" id="L104">          this.retryManagerFuture = rm;</span>
<span class="fc" id="L105">          LOG.debug(&quot;Retry manager started {}&quot;, rm);</span>
        }
<span class="fc" id="L107">      }</span>
    }
<span class="fc" id="L109">  }</span>

  private void shutdownRetryManager() {
<span class="fc" id="L112">    synchronized (sync) {</span>
<span class="fc" id="L113">      Future&lt;?&gt; rmf = this.retryManagerFuture;</span>
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">      if (rmf != null &amp;&amp; rmf != SHUTDOWN) {</span>
<span class="fc" id="L115">        rmf.cancel(true);</span>
<span class="fc" id="L116">        retryManagerFuture = SHUTDOWN;</span>
      }
<span class="fc" id="L118">    }</span>
<span class="fc" id="L119">  }</span>

  private class RetryManager extends AbstractRunnable {

<span class="fc" id="L123">    RetryManager() {</span>
<span class="fc" id="L124">      super(&quot;RetryManager&quot;);</span>
<span class="fc" id="L125">    }</span>

    @Override
    public void doRun() {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">      while (retryManagerFuture != SHUTDOWN) {</span>
        try {
<span class="fc" id="L131">          DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;  event = executionEvents.poll(1, TimeUnit.MINUTES);</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">          if (event != null) {</span>
<span class="fc" id="L133">            RetryFutureTask&lt;?&gt; runnable = event.getRunnable();</span>
<span class="fc" id="L134">            executionService.execute(runnable);</span>
          }
<span class="fc" id="L136">        } catch (InterruptedException ex) {</span>
<span class="fc" id="L137">          Thread.currentThread().interrupt();</span>
<span class="fc" id="L138">          LOG.debug(&quot;Interrupted Retry manager, shuting down, events scheduled: {}&quot;, executionEvents, ex);</span>
<span class="fc" id="L139">          break;</span>
<span class="fc" id="L140">        }</span>
      }
<span class="fc" id="L142">    }</span>

  }

<span class="fc" id="L146">  public FailSafeExecutorImpl(final ExecutorService exec) {</span>
<span class="fc" id="L147">    executionService = exec;</span>
<span class="fc" id="L148">  }</span>

  @Override
  public void close() throws InterruptedException {
<span class="fc" id="L152">    synchronized (sync) {</span>
<span class="fc" id="L153">      Future&lt;?&gt; rmf = this.retryManagerFuture;</span>
<span class="pc bpc" id="L154" title="2 of 4 branches missed.">      if (rmf != null &amp;&amp; rmf != SHUTDOWN) {</span>
<span class="fc" id="L155">        this.retryManagerFuture = SHUTDOWN;</span>
<span class="fc" id="L156">        rmf.cancel(true);</span>
        try {
<span class="nc" id="L158">          rmf.get();</span>
<span class="nc" id="L159">        } catch (ExecutionException ex) {</span>
<span class="nc" id="L160">          throw new UncheckedExecutionException(ex);</span>
<span class="fc" id="L161">        } catch (CancellationException ex) {</span>
          // ignore, since we are the source
<span class="nc" id="L163">        }</span>
      }
<span class="fc" id="L165">    }</span>
<span class="fc" id="L166">  }</span>

  public void initiateClose() {
<span class="fc" id="L169">    shutdownRetryManager();</span>
<span class="fc" id="L170">  }</span>


  @Override
  public &lt;A&gt; Future&lt;A&gt; submit(final Callable&lt;? extends A&gt; task,
          final RetryPredicate&lt;A, ? extends Callable&lt;? extends A&gt;&gt; predicate) {
<span class="fc" id="L176">    RetryFutureTask&lt;A&gt; result =</span>
            new RetryFutureTask(task, (RetryPredicate&lt;A, Callable&lt;? extends A&gt;&gt;) predicate, executionEvents,
              this::startRetryManager);

<span class="fc" id="L180">    executionService.execute(result);</span>
<span class="fc" id="L181">    return (Future&lt;A&gt;) result;</span>
  }

  @Override
  public &lt;A&gt; CompletableFuture&lt;A&gt; submitRx(final Callable&lt;? extends A&gt; task,
          final RetryPredicate&lt;A, ? extends Callable&lt;? extends A&gt;&gt; predicate,
          final Supplier&lt;InterruptibleCompletableFuture&lt;A&gt;&gt; cfSupplier) {
<span class="nc" id="L188">    InterruptibleCompletableFuture&lt;A&gt; result = cfSupplier.get();</span>
<span class="nc" id="L189">    ConsumableRetryFutureTask&lt;A&gt; rft =</span>
            new ConsumableRetryFutureTask&lt;&gt;(f -&gt; {
              A r;
              try {
<span class="nc" id="L193">                r = f.get();</span>
<span class="nc" id="L194">              } catch (ExecutionException ex)  {</span>
<span class="nc" id="L195">                return result.completeExceptionally(ex.getCause());</span>
<span class="nc" id="L196">              } catch (Throwable ex)  {</span>
<span class="nc" id="L197">                return result.completeExceptionally(ex);</span>
<span class="nc" id="L198">              }</span>
<span class="nc" id="L199">              return result.complete(r);</span>
            }, (Callable&lt;A&gt;) task,
                    (RetryPredicate&lt;A, Callable&lt;? extends A&gt;&gt;) predicate, executionEvents,
              this::startRetryManager);
<span class="nc" id="L203">    result.setToCancel(rft);</span>
<span class="nc" id="L204">    executionService.execute(rft);</span>
<span class="nc" id="L205">    return result;</span>
  }

  @Override
  public &lt;A&gt; Future&lt;A&gt; submit(final Callable&lt;? extends A&gt; task,
          final RetryPredicate&lt;A, ? extends Callable&lt;? extends A&gt;&gt; predicate,
          final int nrHedges, final long hedgeDelay, final TimeUnit unit) {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">    if (nrHedges &lt;= 0) {</span>
<span class="nc" id="L213">      return submit(task, predicate);</span>
    }
<span class="fc" id="L215">    int nrFut = nrHedges + 1;</span>
<span class="fc" id="L216">    final Future[] futures = new Future[nrFut];</span>
<span class="fc" id="L217">    ArrayBlockingQueue&lt;Future&lt;A&gt;&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);</span>
<span class="fc" id="L218">    FirstFuture&lt;A&gt; result = new FirstFuture&lt;A&gt;(futures, queue);</span>
<span class="fc" id="L219">    ConsumableRetryFutureTask&lt;A&gt; future =  new ConsumableRetryFutureTask(result, task,</span>
            (RetryPredicate&lt;A, Callable&lt;? extends A&gt;&gt;) predicate, executionEvents, this::startRetryManager);
<span class="fc" id="L221">    startRetryManager();</span>
<span class="fc" id="L222">    futures[0] = future;</span>
<span class="fc" id="L223">    Runnable[] submits = new Runnable[nrFut];</span>
<span class="fc" id="L224">    submits[0] = () -&gt; executionService.execute(future);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">    for (int i = 1; i &lt; nrFut; i++) {</span>
<span class="fc" id="L226">      ConsumableRetryFutureTask&lt;A&gt; f = new ConsumableRetryFutureTask(</span>
                result, task, (RetryPredicate) predicate, executionEvents,
                this::startRetryManager);
<span class="fc" id="L229">      futures[i] = f;</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">      if (hedgeDelay &gt; 0) {</span>
<span class="fc" id="L231">        DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;  delayedExecution = new DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;(</span>
<span class="fc" id="L232">                f, unit.toNanos(hedgeDelay));</span>
<span class="fc" id="L233">        f.setExec(delayedExecution);</span>
<span class="fc" id="L234">        submits[i] = () -&gt; executionEvents.add(delayedExecution);</span>
<span class="fc" id="L235">      } else {</span>
<span class="fc" id="L236">        submits[i] = () -&gt; executionService.execute(f);</span>
      }
    }
<span class="fc bfc" id="L239" title="All 2 branches covered.">    for (Runnable submit : submits) {</span>
<span class="fc" id="L240">      submit.run();</span>
    }
<span class="fc" id="L242">    return result;</span>
  }

  @Override
  public &lt;A&gt; CompletableFuture&lt;A&gt; submitRx(final Callable&lt;? extends A&gt; task,
          final RetryPredicate&lt;A, ? extends Callable&lt;? extends A&gt;&gt; predicate,
          final int nrHedges, final long hedgeDelay, final TimeUnit unit,
          final Supplier&lt;InterruptibleCompletableFuture&lt;A&gt;&gt; cfSupplier) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">    if (nrHedges &lt;= 0) {</span>
<span class="nc" id="L251">      return submitRx(task, predicate);</span>
    }
<span class="nc" id="L253">    InterruptibleCompletableFuture&lt;A&gt; result = cfSupplier.get();</span>
<span class="nc" id="L254">    int nrFut = nrHedges + 1;</span>
<span class="nc" id="L255">    final Future&lt;A&gt;[] futures = new Future[nrFut];</span>
<span class="nc" id="L256">    ArrayBlockingQueue&lt;Future&lt;A&gt;&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);</span>
<span class="nc" id="L257">    FirstFuture&lt;A&gt; resultX = new FirstFuture&lt;A&gt;(futures, queue) {</span>
      @Override
      @SuppressFBWarnings({ &quot;NOS_NON_OWNED_SYNCHRONIZATION&quot;, &quot;EXS_EXCEPTION_SOFTENING_NO_CHECKED&quot; })
      public boolean accept(final Future&lt;A&gt; finished) {
<span class="nc" id="L261">        boolean accepted = super.accept(finished);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">          if (accepted) {</span>
            A r;
            try {
<span class="nc" id="L265">              r = finished.get();</span>
<span class="nc" id="L266">            } catch (ExecutionException ex) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">              if (!result.completeExceptionally(ex.getCause())) {</span>
<span class="nc" id="L268">                throw new IllegalStateException(ex);</span>
              }
<span class="nc" id="L270">              return true;</span>
<span class="nc" id="L271">            } catch (Throwable ex) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">              if (!result.completeExceptionally(ex)) {</span>
<span class="nc" id="L273">                throw new IllegalStateException(ex);</span>
              }
<span class="nc" id="L275">              return true;</span>
<span class="nc" id="L276">            }</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (!result.complete(r)) {</span>
<span class="nc" id="L278">              throw new IllegalStateException();</span>
            }
<span class="nc" id="L280">            return true;</span>
          }
<span class="nc" id="L282">          return false;</span>
      }
    };
<span class="nc" id="L285">    result.setToCancel(resultX);</span>
<span class="nc" id="L286">    ConsumableRetryFutureTask&lt;A&gt; future =  new ConsumableRetryFutureTask(resultX, task,</span>
            (RetryPredicate&lt;A, Callable&lt;? extends A&gt;&gt;) predicate, executionEvents, this::startRetryManager);
<span class="nc" id="L288">    startRetryManager();</span>
<span class="nc" id="L289">    futures[0] = future;</span>
<span class="nc" id="L290">    Runnable[] submits = new Runnable[nrFut];</span>
<span class="nc" id="L291">    submits[0] = () -&gt; executionService.execute(future);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">    for (int i = 1; i &lt; nrFut; i++) {</span>
<span class="nc" id="L293">      ConsumableRetryFutureTask&lt;A&gt; f = new ConsumableRetryFutureTask(</span>
                resultX, task, (RetryPredicate) predicate, executionEvents,
                this::startRetryManager);
<span class="nc" id="L296">      futures[i] = f;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      if (hedgeDelay &gt; 0) {</span>
<span class="nc" id="L298">        DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;  delayedExecution = new DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;(</span>
<span class="nc" id="L299">                f, unit.toNanos(hedgeDelay));</span>
<span class="nc" id="L300">        f.setExec(delayedExecution);</span>
<span class="nc" id="L301">        submits[i] = () -&gt; executionEvents.add(delayedExecution);</span>
<span class="nc" id="L302">      } else {</span>
<span class="nc" id="L303">        submits[i] = () -&gt; executionService.execute(f);</span>
      }
    }
<span class="nc bnc" id="L306" title="All 2 branches missed.">    for (Runnable submit : submits) {</span>
<span class="nc" id="L307">      submit.run();</span>
    }
<span class="nc" id="L309">    return result;</span>
  }



  @Override
  public &lt;A&gt; void execute(final Callable&lt;? extends A&gt; task,
          final RetryPredicate&lt;A, ? extends Callable&lt;? extends A&gt;&gt; predicate) {
<span class="nc" id="L317">    RetryFutureTask&lt;A&gt; result = new RetryFutureTask(task, predicate, executionEvents, this::startRetryManager);</span>
<span class="nc" id="L318">    executionService.execute(result);</span>
<span class="nc" id="L319">  }</span>


  @Override
  public String toString() {
<span class="nc" id="L324">    return &quot;RetryExecutor{&quot; + &quot;executionService=&quot; + executionService + &quot;, executionEvents=&quot; + executionEvents</span>
            + &quot;, retryManagerFuture=&quot; + retryManagerFuture
            + &quot;, sync=&quot; + sync + '}';
  }

  @SuppressFBWarnings(&quot;NOS_NON_OWNED_SYNCHRONIZATION&quot;) // Actually I own it...
  private static class FirstFuture&lt;T&gt; implements Future&lt;T&gt;, ConditionalConsumer&lt;Future&lt;T&gt;&gt; {

    private final Future&lt;T&gt;[] futures;
    private final BlockingQueue&lt;Future&lt;T&gt;&gt; queue;
<span class="fc" id="L334">    private boolean first = true;</span>

    FirstFuture(final Future&lt;T&gt;[] futures,
<span class="fc" id="L337">            final BlockingQueue&lt;Future&lt;T&gt;&gt; queue) {</span>
<span class="fc" id="L338">      this.futures = futures;</span>
<span class="fc" id="L339">      this.queue = queue;</span>
<span class="fc" id="L340">    }</span>

    @Override
    public boolean accept(final Future&lt;T&gt; finished) {
<span class="fc" id="L344">      synchronized (this) {</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (first) {</span>
<span class="fc" id="L346">          first = false;</span>
<span class="fc" id="L347">          queue.add(finished);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">          for (int i = 0;  i &lt; futures.length; i++) {</span>
<span class="fc" id="L349">            Future f = futures[i];</span>
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">            if (f != null &amp;&amp; f != finished) {</span>
<span class="fc" id="L351">              f.cancel(true);</span>
            }
<span class="fc" id="L353">            futures[i] = null;</span>
          }
<span class="fc" id="L355">          return true;</span>
        }
<span class="fc" id="L357">        return false;</span>
      }
    }

    @Override
    public boolean cancel(final boolean mayInterruptIfRunning) {
<span class="fc" id="L363">      synchronized (this) {</span>
<span class="fc" id="L364">        boolean result = true;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (int i = 0, l = futures.length; i &lt; l; i++) {</span>
<span class="fc" id="L366">          Future f = futures[i];</span>
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">          if (f != null &amp;&amp; !f.cancel(mayInterruptIfRunning)) {</span>
<span class="nc" id="L368">            result = false;</span>
          }
        }
<span class="fc" id="L371">        return result;</span>
      }
    }

    @Override
    public boolean isCancelled() {
<span class="nc" id="L377">      synchronized (this) {</span>
<span class="nc" id="L378">        boolean result = true;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (int i = 0, l = futures.length; i &lt; l; i++) {</span>
<span class="nc" id="L380">          Future f = futures[i];</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">          if (f != null &amp;&amp; !f.isCancelled()) {</span>
<span class="nc" id="L382">            result = false;</span>
          }
        }
<span class="nc" id="L385">        return result;</span>
      }
    }

    @Override
    public boolean isDone() {
<span class="fc" id="L391">      boolean result = true;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">      for (int i = 0, l =  futures.length; i &lt; l; i++) {</span>
<span class="fc" id="L393">        Future f  = futures[i];</span>
<span class="pc bpc" id="L394" title="3 of 4 branches missed.">        if (f != null &amp;&amp; !f.isDone()) {</span>
<span class="nc" id="L395">          result =  false;</span>
        }
      }
<span class="fc" id="L398">      return result;</span>
    }

    @Override
    public T get() throws InterruptedException, ExecutionException {
<span class="fc" id="L403">      return queue.take().get();</span>
    }

    @Override
    public T get(final long timeout, final TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
<span class="fc" id="L409">      Future&lt;T&gt; poll = queue.poll(timeout, unit);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">      if (poll == null) {</span>
<span class="fc" id="L411">        throw new TimeoutException(&quot;Timed out after &quot; + timeout + &quot; &quot; + unit);</span>
      } else {
<span class="fc" id="L413">        return poll.get();</span>
      }
    }
  }

  private static class ConsumableRetryFutureTask&lt;T&gt; extends RetryFutureTask&lt;T&gt; {

    private final ConditionalConsumer&lt;Future&lt;T&gt;&gt; consumer;

    ConsumableRetryFutureTask(final ConditionalConsumer&lt;Future&lt;T&gt;&gt; consumer, final Callable&lt;T&gt; callable,
            final RetryPredicate&lt;T, Callable&lt;? extends T&gt;&gt; retryPredicate,
            final DelayQueue&lt;DelayedTask&lt;RetryFutureTask&lt;?&gt;&gt;&gt; delayedTasks,
            final Runnable onRetry) {
<span class="fc" id="L426">      super(callable, retryPredicate, delayedTasks, onRetry);</span>
<span class="fc" id="L427">      this.consumer = consumer;</span>
<span class="fc" id="L428">    }</span>

    @Override
    public void done() {
<span class="fc" id="L432">      consumer.accept(this);</span>
<span class="fc" id="L433">    }</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>